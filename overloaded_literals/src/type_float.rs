//! Lifting of a [f64] literal to the type level,
//! to allow usage of a `const f64` in generic const contexts
//! (which is otherwise not allowed on stable Rust currently.)
//!
//! Items in this module need to be public as the types and structs contained within
//! are built by the `overloaded_literals!` macro.
//!
//! However, **consider the contents of this module an implementation detail,
//! and do not depend on these details directly in your code. They are subject to change**.
//!
//! The only API which can be considered public and is guaranteed, is [TypeFloat::FLOAT].

use crate::sealed::Sealed;

/// Struct to lift a single f64 to the type level.
///
/// Implementation detail of [TypeFloat].
pub struct Float<const FLOAT_BITS: u64>;

impl<const FLOAT_BITS: u64> Sealed for Float<FLOAT_BITS> {}

/// Trait to work with [f64]s at the type level, allowing `f64` in 'const generic' contexts.
///
/// Objects of this trait are automatically generated by the [overloaded_literals](macro@crate::overloaded_literals) macro.
pub trait TypeFloat: Sealed {
    /// Turns this TypeFloat into its const `f64` equivalent.
    /// This associated constant is part of the **stable API** of `TypeFloat`.
    const FLOAT: f64;
}

impl<const FLOAT_BITS: u64> TypeFloat for Float<FLOAT_BITS> {
    const FLOAT: f64 = {
        unsafe { core::mem::transmute(FLOAT_BITS)}
    };
}
